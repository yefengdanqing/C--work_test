#include "MyString.h"
char* MyString::alloc_n_copy(const char* s)//分配空间？？
{
	m_data=alloc.allocate(strlen(s)+1);
	char *p=m_data;
	int i=0;
	while(s[i]!='\0')
	{
		alloc.construct(p++,s[i++]);
	}
	alloc.construct(p,s[i]);
	return m_data;
}
void MyString::free()//
{
	char* p=m_data;
	size_t num=strlen(p)+1;
	while (*p!='\0')
	{
		alloc.destroy(p++);
	}
	alloc.destroy(p);
	alloc.deallocate(m_data,num);
}
MyString::MyString(char* s)
{
	std::cout<<"构造函数"<<std::endl;
	if (s==nullptr)
	{
		m_data=new char[1];
		*m_data='\0';
	} 
	else
	{
		//m_data=alloc_n_copy(s);
		int num=strlen(s);
		m_data=new char[num+1];
		strcpy(m_data,s);
		std::cout<<*m_data<<std::endl;
	}
}
MyString::MyString(const MyString& str)//注意验证是否为空
{
	//不明白这个函数是啥意思
	//m_data=alloc_n_copy(str.m_data);
	//alloc_n_copy()分配内存空间并给
	if (str.m_data==nullptr)
	{
		delete m_data;
	}
	int len=strlen(str.m_data);
	m_data=new char[len+1];
	strcpy(m_data,str.m_data);//从第二个参数的起始地址开始到结束（包含'0')，复制到第一个参数开始的地址空间
	//赋值的是内容
}
size_t MyString::sizeStr()
{
	return strlen(m_data);
}
MyString& MyString::operator=(const MyString& obj)
{
	//处理自复制
	if (this==&obj)//this 到底是什么类型
	{
		return *this;//this 是一个右值？？
	}
	if (m_data!=nullptr)
	{
		delete m_data;
		m_data=nullptr;
	}
	int length=strlen(obj.m_data);
	m_data=new char[length+1];
	memset(m_data,0,sizeof(length+1));//格式化字节
	strcpy(m_data,obj.m_data);
	return *this;//因为返回MyString&，return *this
}
std::ostream& operator<<(std::ostream& os,const MyString& rhs)
{
	os<<rhs.m_data;
}
std::istream& operator>>(std::istream& is,MyString& lhs)
{//应该捕捉一个异常,并且不控制格式化
	if (is)
	{
		is>>lhs.m_data;
	}
	else
	{
		lhs=MyString();//空构造函数初始化
	}
}
MyString& MyString::operator+=(const MyString& obj2)
{
	char* tempt;
	tempt=m_data;

	if (m_data!=nullptr)
	{
		delete m_data;
		m_data=nullptr;
	}
	int length1=strlen(obj2.m_data)+strlen(tempt);
	m_data=new char[length1+1];
	memset(m_data,0,sizeof(length1));
	//strcpy(m_data,obj2.m_data);
	strcat(m_data,obj2.m_data);
	delete tempt;
	return *this;
}
MyString operator+(MyString& lhs,const MyString& rhs)
{
	lhs+=rhs;
	return lhs;
}
bool operator<(const MyString& lhs,const MyString& rhs)
{
	if(-1==strcmp(lhs.m_data,rhs.m_data))
	{
		return true;
	}
	else
	{
		return false;
	}
}
bool operator==(const MyString& lhs,const MyString& rhs)
{
	if (0==strcmp(lhs.m_data,rhs.m_data))
	{
		return true;
	}
	else
	{
		return false;
	}
}
bool operator!=(const MyString& lhs,const MyString& rhs)
{
	return !(lhs==rhs);
}
