#ifndef MYSTRING_H
#define MYSTRING_H
#include <iostream>
#include <cstring>
#include <memory>
#include <string>
class MyString
{
	friend std::ostream& operator<<(std::ostream&,const MyString&);//不用处理可能出错的情况
	friend std::istream& operator>>(std::istream&,MyString&);//必须处理可能出错的情况

	friend bool operator<(const MyString&,const MyString&);
	friend bool operator==(const MyString&,const MyString&);
	friend bool operator!=(const MyString&,const MyString&);
	friend MyString operator+(MyString,const MyString&);
public:
	MyString();//根据标准库string，还有n个构造函数，看看stl
	MyString(char*);
	MyString(const MyString&);//常量，拷贝构造函数
	//复制
	MyString(char,int);
	MyString(int);
	MyString& operator= (const MyString&);//赋值运算符
	char& operator[](int);//定义两个版本
	const char& operator[](int)const;//重载下标运算符
	MyString& operator++();  //前置版本,由于是成员函数，只有一个参数，函数中没有参数
	MyString operator++(int);//后置版本,假如返回引用则是递增之后的值，而后置返回的是原值。需要记录原值
	MyString& operator--();  //前置版本在递增前要判断是否到达末尾，递减要判断是否出界
	MyString operator--(int);//后置调用前置版本
	size_t sizeStr();        //求解string的长度
	MyString& operator+=(const MyString&);//可能没有用
	MyString& operator-=(const MyString&);
	~MyString();
	MyString operator()(int,int);
	int myfind(char) const;
private:
	char* m_data;
	char* alloc_n_copy(const char* s);//暂时不明白是用来干嘛的
	void free();
	static std::allocator<char>alloc;
	size_t strLength;
	
};
#endif
